## 📅 날짜 : 2025-02-10

### 💬 스크럼
- 학습 목표 1 : Docker 개념 이해하기

### 📒 새로 배운 내용
#### 주제 1 : **Docker**
> 컨테이너 기반의 오픈소스 가상화 플랫폼, 컨테이너(작은 소프트웨어 유닛) 안에 애플리케이션과 그에 필요한 시스템 툴, 환경설정, 모든 디펜던시를 하나에 묶어 쉽게 배포하고 안정적으로 구동할 수 있게 도와주는 툴
- 도커 컨테이너는 가상화된 공간을 생성할 때 리눅스 자체 기능을 사용하여 프로세스 단위의 격리 환경을 만드므로 `성능 손실 無`
- 가상머신과 달리 커널을 공유해서 사용하므로, 컨테이너에는 라이브러리 및 실행파일만 있으므로 `용량이 작음`
- 위의 이유로 컨테이너를 이미지로 만들었을 때 `배포하는 시간이 가상 머신에 비해 빠르며, 사용할 때의 성능 손실 또한 거의 없음`
- VM과 비교
  - 가상머신은 Hypervisor를 통해 여러개의 운영체제를 생성되고 관리됨. (Guest OS)
  - 시스템 자원을 가상화하고 독립된 공간을 생성하는 작업은 HyperVisor를 거치므로 `성능 손실이 큼`
  - 가상머신은 Guest OS를 사용하기 위한 라이브러리, 커널 등을 포함하므로 `배포할 때 용량이 큼`
- 구성 요소
  - Docker Client : 도커를 설치하면 그것이 Client며 build, pull, run 등의 도커 명령어를 수행한다.
  - DOCKER_HOST : 도커가 띄워져있는 서버를 의미하며, 컨테이너와 이미지를 관리한다.
  - Docker daemon : 도커 엔진
  - Registry : 외부(remote) 이미지 저장소로 다른 사람들이 공유한 이미지를 내부(local) 도커 호스트에 pull할 수 있다. 이렇게 가져온 이미지를 run하면 컨테이너가 된다.
    - public registry **:** Docker Hub, QUAY
    - private registry : **** AWS ECR 혹은 Docker Registry를 직접 띄워서 비공개로 사용하는 방법 등    

#### 주제 2 : **Dockerfile**
> 컨테이너를 어떻게 만들어야 하는지에 대한 설명서, Dockerfile을 빌드하면 자동으로 이미지가 생성됨 → 도커 파일을 통해 애플리케이션 빌드 및 배포를 자동화할 수 있음 
- Instructions
  1. FROM : base image 지정 , 이미지의 기초
  2. RUN : command를 실행하여 새 이미지에 포함시킴 → apk 설치 등등 / 이미지 빌드 시
  3. CMD : 컨테이너가 시작 될 때 실행할 command 지정 / 빌드 완료 된 이미지로 부터 시작
  4. ENTRYPOINT : 컨테이너 시작 시 실행될 command 지정 + param 변경 불가
  5. LABEL : key-value 형식으로 작성된 메타데이터를 이미지에 추가
  6. ENV : key-value 형식으로 환경변수를 설정
  7. EXPOSE : 컨테이너로 들어오는 트래픽을 특정 포트로 받아들일 수 있도록 지정하는 역할 → <포트>/<프로토콜>
  8. COPY : Host내에 있는 파일 또는 디렉토리를 컨테이너의 파일시스템으로 복사
  9. ADD : 파일 또는 디렉토리를 컨테이너로 복사 → remote 파일, 디렉토리를 복사 할 수 있음
  10. USER : 명령을 실행할 유저명, 유저 그룹 설정 → 사용자계정으로 변경
  11. WORKDIR : 작업 디렉토리 설정 / 기존 디렉토리 없을 때 생성 후 설정
  12. VOLUME : 컨테이너 내의 특정 디렉토리를  컨테이너 외부 경로에 마운트 시켜주는 지시자 → 데이터 보존

#### 주제 3 : **Image**
> 컨테이너를 실행할 수 있는 실행파일, 설정 값들을 가지고 있는 것으로 Image를 컨테이너에 담고 실행시키면 해당 프로세스가 동작한다.
- 기존 이미지에 추가적인 구성이 필요할 때 다시 다운로드 하는 방법이 아니라 기존 이미지에 레이어를 추가하여 구성을 올려주는 방식으로 생성된다.
- 여러 개의 읽기 전용 레이어로 구성되고 파일이 추가되면 새로운 레이어가 생성되어 추가된다.
- 도커는 여러 개의 레이어를 묶어 하나의 파일 시스템으로 사용할 수 있게 해준다.
- 형태 : [저장소 이름]/[이미지 이름]:[태그]
  - 저장소 이름 : 이미지가 저장된 장소, 저장소 이름이 명시되지 않은 이미지는 도커 허브의 공식 이미지를 뜻한다
  - 이미지 이름 : 해당 이미지가 어떤 역할을 하는지 나타내며 필수로 설정해야 한다. <br>
    i.e., ubuntu:latest → 우분투 컨테이너를 생성하기 위한 이미지라는 것을 나타낸다.
  - 태그 : 이미지의 버전, 태그를 생략하면 도커 엔진은 latest로 인식한다.
    
#### 주제 4 : **Container**
> Image를 고립된 환경에서, 개별적인 시스템 안에서 실행할 수 있는 공간
- container는 베이스 환경의 OS를 모두 공유하면서 필요한 프로세스만 격리하는 방식으로, 커널을 공유하기 때문에 Host OS의 기능을 모두 사용할 수 있다. 때문에 container 위에서는 Host OS와 다른 OS를 구동할 수 없다.
- 운영체제가 아닌 프로세스이며, Hypervisor를 거칠 필요가 없어 실행 속도가 빠르다. 
- 격리시킬 애플리케이션과 필요한 파일이나 특정 라이브러리 등 종속 항목만 포함하여 배포를 위해 생성되는 이미지의 용량이 작아진다.
  
#### 주제 5 : **Volume과 Bind Mount**
1. Volume
   > 컨테이너 내부의 데이터를 외부로 링크 걸어주는 기능으로 컨테이너 내부에서 데이터 수정 시, 볼륨이 걸려 있는 외부의 데이터도 같이 수정되며 해당 컨테이너가 삭제되어도 외부에 남음.
   - 주어진 볼륨은 여러 컨테이너에 동시에 탑재할 수 있으며, 실행 중인 컨테이너가 볼륨을 사용하지 않는 경우에도 해당 볼륨은 사라지지 않고 도커에서 계속 사용할 수 있다. 명령어를 사용하여 사용하지 않는 볼륨을 제거할 수 있다.
2. Bind Mount
   > 바인드 마운트를 사용하면 호스트 시스템의 파일 또는 디렉토리가 컨테이너에 마운트되며, 파일 또는 디렉토리는 호스트 시스템의 전체 경로로 참조된다.

### 🔥 오늘의 도전 과제와 해결 방법
- 도전 과제 1 : 없음. 

### 💭 오늘의 회고
- Liked <br>
  항상 공부해야지 다짐만 했던 Docker에 대해 드디어 공부하게 되어 좋았다.
- Learned <br>
  오늘 배운 것은 전부 다 새로운 개념이라 다시 보고 공부할 필요성이 있다.
- Lacked <br>
  전혀 모르는 개념이다 보니 이해하기 어렵긴 했다. 미리 Docker에 대한 글을 읽어 보고 강의를 들었으면 좋을 것 같았다.
- Longed for <br>
  다음 주 개념 시간 전에는 미리 개념을 찾아보아야 겠다...


### 📁 참고 자료 및 링크
- [도커란 무엇인가? 도커 한방 정리!](https://be-developer.tistory.com/18)
- [도커란? 도커 개념 정리](https://seosh817.tistory.com/345#Virtual%20Machine(%EA%B0%80%EC%83%81%EB%A8%B8%EC%8B%A0)%C2%A0-1)
