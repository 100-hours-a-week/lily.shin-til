## 📅 날짜 : 2025-02-17

### 💬 스크럼
- 학습 목표 1 : Kubernetes 개념 이해하기

### 📒 새로 배운 내용
#### 주제 1 : **쿠버네티스 API (kubectl)**
쿠버네티스는 모두 API로 동작한다. 
| **커맨드** | **동작** |
| --- | --- |
| `kubectl cluster-info` | K8s 클러스터의 엔드포인트를 표시 |
| `kubectl get no` | K8s 클러스터를 구성하는 노드 목록 표시 |
| `kubectl run` | 파드를 실행 |
| `kubectl get po` | 파드의 목록 출력 |
| `kubectl delete po` | 파드의 이름을 지정해서 삭제 |
| `kubectl get all` | 모든 오브젝트를 출력 |
| `kubectl logs` | 컨테이너 프로세스가 STDOUT이나 STDERR로 출력하는 로그를 표시 |
| `kubectl get deploy,po` | 디플로이먼트와 파드의 목록을 표시 |
| `kubectl get deploy` | 디플로이먼트 목록 표시 |
| `kubectl delete deploy` | 디플로이먼트와 관련 리플리카셋 및 파드를 일괄 삭제 |
| `kubectl get jobs` | 잡의 실행 상태를 출력 |
| `kubectl create job` | 잡 컨트롤러 제어 하에서 파드를 실행 |
| `kubectl create deployment` | 디플로이먼트 컨트롤러 제어 하에서 파드를 실행 |
| `kubectl scale` | 레플리카 수 변경 |
- busybox
  ```
  kubectl run busybox --image=busybox --restart=Never --rm -it sh
  ```
  - 다양한 Unix 명령어를 하나의 실행 파일로 포함한 초소형 리눅스 배포판
  - `kubectl exec` 대신 빠르게 컨테이너를 실행하고 특정 명령을 수행할 때 유용 
 
#### 주제 2 : **Pod**
> 하나의 목적을 위해 만들어진 컨테이너를 부품처럼 조합할 수 있도록 설계한다
- localhost로 서로 통신할 수 있다
- 파드의 IP는 DHCP에 의해 기동 시 부여되고 삭제될 때 회수된다.
- 파드에 요청을 보낼 때 반드시 서비스 오브젝트를 사용해야 한다.
- 파드의 볼륨을 마운트하여 파일 시스템 공유가 가능하다.
- 스케쥴러가 새로 생성된 모든 파드에 대해 실행할 최적의 노드를 선택하는 것.
- 파드를 확장한다고 할 때, IP나 Worker node 리소스가 부족할 수 있으므로 이를 고려해야 한다.

#### 주제 3 : **서비스**
1. 대표 IP 주소 <br>
서비스의 대표 IP 주소(Cluster IP)는 변하지 않기 때문에 클라이언트가 안정적으로 접근할 수 있도록 보장한다.
- 파드의 IP 주소가 바뀌는 이유
    - 파드는 삭제되거나 다시 실행될 때마다 새로운 IP 주소를 받는다.
    - 특정 노드에서 실행되던 파드가 다른 노드로 이동할 수도 있다.
    - 따라서 직접 파드의 IP를 사용하면 연결이 끊어질 위험이 있다.
- 해결 방법: 서비스 IP(Cluster IP)
    - 서비스는 여러 개의 파드를 관리하면서 변하지 않는 대표 IP 주소를 제공한다.
    - 클라이언트는 개별 파드가 아니라 서비스의 대표 IP를 통해 접근하면 된다.
2. 부하분산 <br>
Kubernetes 서비스는 부하 분산을 자동으로 수행한다.
- 클라이언트가 서비스의 IP 주소(Cluster IP)로 요청을 보낸다.
- 서비스는 selector에 맞는 여러 개의 파드 중 하나를 선택한다.
- Kubernetes는 요청을 선택된 파드로 전달한다.
즉, 클라이언트는 서비스만 바라보면 되고, 서비스가 적절한 파드로 연결을 담당한다.
3. 이름 해결 <br>
Kubernetes 내부에는 DNS 서비스(CoreDNS)가 실행되고 있으며, 서비스가 생성되면 자동으로 내부 DNS에 등록된다.
- Kubernetes에서 이름 해결이 필요한 이유
    - 직접 IP 주소를 사용하면 파드가 재시작될 때마다 IP가 변경되므로 비효율적이다.
    - DNS를 이용하면 고정된 서비스 이름으로 항상 접근할 수 있다.

#### 주제 3 : **컨트롤러**
> 파드를 제어하고 관리하는 역할을 하는 핵심 컴포넌트 
특정 목적을 가지고 파드의 개수, 상태, 배치 등을 자동으로 조정해서 클러스터가 원하는 상태를 유지하도록 한다.

| 컨트롤러 | 역할 | 추가 설명 |
| --- | --- | --- |
| **디플로이먼트 (Deployment)** | 애플리케이션을 배포하고, 파드의 롤링 업데이트 및 롤백을 관리. 여러 개의 파드로 수평한 클러스터를 구성할 때 사용 | 새로운 버전을 점진적으로 배포할 때 사용 (무중단 배포 가능). 웹서버나 API 서버처럼 지속적으로 서비스를 제공해야 하는 워크로드에 적합 |
| **스테이트풀셋 (StatefulSet)** | 데이터베이스처럼 상태(Stateful)가 필요한 애플리케이션을 배포 | 파드에 고유한 네트워크 ID를 부여하고, 퍼시스턴트 볼륨(PV)을 유지 |
| **잡 (Job)** | 배치 작업을 실행하고, 작업이 완료될 때까지 반복 실행 | 특정 작업(예: 데이터 처리, 백업)을 한 번 실행하고 종료. 파드의 실행 횟수, 동시 실행 개수, 실행 횟수 상한값을 설정, 파드 삭제 전까지 로그를 보존 |
| **크론잡 (CronJob)** | 지정된 시간에 주기적으로 잡을 실행 | Linux `cron` 명령어처럼 정해진 시간마다 작업 실행 |
| **데몬셋 (DaemonSet)** | 모든 노드에서 특정 파드를 실행 (노드 모니터링, 로그 수집) | 새 노드가 추가되면 자동으로 해당 파드를 실행. 로그 외부로 뺄 때 사용 |
| **리플리카셋 (ReplicaSet)** | 파드 개수를 일정하게 유지하여 가용성을 보장 | 디플로이먼트가 내부적으로 사용하는 컨트롤러 (직접 사용할 일은 적음) |
| **레플리케이션 컨트롤러 (Replication Controller)** | 파드 개수를 일정하게 유지하는 옛날 방식의 컨트롤러 | 현재는 **ReplicaSet + Deployment**로 대체됨 |

### 🔥 오늘의 도전 과제와 해결 방법
- 도전 과제 1 : 아직 배운 개념들을 다 정리하지 못했다. 자기 전까지 정리 완료하기!

### 💭 오늘의 회고
- Learned <br>
  모든 것이 다 새롭다~
- Lacked <br>
  전체적인 흐름이 잘 안 그려진다. 흐름 정리를 해봐야 할 거 같다.
